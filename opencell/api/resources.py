import os
import io
import urllib
import imageio
import tifffile
import pandas as pd
import sqlalchemy as db

from flask_restful import Resource, reqparse
from flask import (
    current_app,
    jsonify,
    request,
    send_file,
    abort
)

from opencell.imaging import utils
from opencell.api.cache import cache
from opencell.database import models, operations, payloads
from opencell.database import utils as db_utils
from opencell.imaging.processors import FOVProcessor


# copied from https://stackoverflow.com/questions/24816799/how-to-use-flask-cache-with-flask-restful
def cache_key():
    args = request.args
    key = request.path + '?' + urllib.parse.urlencode([
        (k, v) for k in sorted(args) for v in sorted(args.getlist(k))
    ])
    return key


class Plates(Resource):

    def get(self):
        '''
        All plate designs/instances
        '''
        raise NotImplementedError


class Plate(Resource):

    def get(self, plate_id):
        '''
        Get a plate design by design_id

        TODO: handle invalid plate_id (what error code to return?)
        '''
        plate = (
            current_app.Session.query(models.PlateDesign)
            .filter(models.PlateDesign.design_id == plate_id)
            .one_or_none()
        )

        targets = [d.target_name for d in plate.crispr_designs]

        return {
            'plate_id': plate.design_id,
            'targets': targets,
        }


class PolyclonalLines(Resource):

    @cache.cached(timeout=3600, key_prefix=cache_key)
    def get(self):
        '''
        All polyclonal lines
        (that is, all lines directly generated by an electroporation)
        '''

        args = request.args
        kind = args.get('kind')
        plate_id = args.get('plate_id')
        target_name = args.get('target_name')

        valid_kinds = ['scalars', 'facs', 'ms', 'rois', 'thumbnails', 'all']
        if kind is not None and kind not in valid_kinds:
            abort(404)

        query = current_app.Session.query(models.CrisprDesign)
        if plate_id:
            query = query.filter(models.CrisprDesign.plate_design_id == plate_id)

        # look for an exact match to the target_name; if none, filter by startswith
        if target_name:
            exact_query = query.filter(
                db.func.lower(models.CrisprDesign.target_name) == target_name.lower()
            )
            if not exact_query.all():
                query = query.filter(
                    db.func.lower(models.CrisprDesign.target_name)
                    .startswith(target_name.lower())
                )
            else:
                query = exact_query

        ids = []
        [ids.extend([line.id for line in design.cell_lines]) for design in query.all()]

        query = (
            current_app.Session.query(models.CellLine)
            .filter(models.CellLine.id.in_(ids))
        )
        if kind == 'microscopy':
            query = query.options(
                db.orm.joinedload(models.CellLine.fovs, innerjoin=True)
                .joinedload(models.MicroscopyFOV.results, innerjoin=True)
            )

        payload = []
        for line in query.all():
            payload.append(payloads.construct_payload(line, kind=kind))
        return jsonify(payload)


class PolyclonalLine(Resource):

    def get(self, cell_line_id):
        '''
        '''
        args = request.args
        kind = args.get('kind')
        ops = operations.PolyclonalLineOperations.from_line_id(
            current_app.Session, cell_line_id)
        return jsonify(payloads.construct_payload(ops.line, kind=kind))


class MicroscopyFOV(Resource):

    def get(self, fov_id, channel, kind):
        '''
        Return the specified kind of processed data
        for a single FOV using Flask's send_file method

        Currently, only works for kind = 'proj'
        '''

        fov = (
            current_app.Session.query(models.MicroscopyFOV)
            .filter(models.MicroscopyFOV.id == fov_id)
            .one_or_none()
        )
        if not fov:
            abort(404)

        processor = FOVProcessor.from_database(fov)
        dst_root = current_app.config.get('opencell_microscopy_root')
        filepath_405 = processor.dst_filepath(dst_root, kind='proj', channel='405', ext='tif')
        filepath_488 = processor.dst_filepath(dst_root, kind='proj', channel='488', ext='tif')

        ims = {}
        ims['405'] = tifffile.imread(filepath_405)[..., None]
        ims['488'] = tifffile.imread(filepath_488)[..., None]
        ims['rgb'] = processor.make_rgb(ims['405'], ims['488'])

        im = ims.get(channel)
        if channel in ['405', '488']:
            im = utils.autoscale(im, p=1)

        file = io.BytesIO()
        imageio.imsave(file, im, format='jpg', quality=90)
        file.seek(0)

        filename = 'FOV%04d_%s-%s.jpg' % (fov_id, kind.upper(), channel.upper())
        return send_file(file, as_attachment=True, attachment_filename=filename)


class MicroscopyFOVROI(Resource):

    def get(self, roi_id, channel, kind):
        '''
        Get the stack for a given roi_id as a tiled PNG
        Note that, for now, `kind` is hard-coded
        '''

        roi = (
            current_app.Session.query(models.MicroscopyFOVROI)
            .filter(models.MicroscopyFOVROI.id == roi_id)
            .one()
        )

        processor = FOVProcessor.from_database(roi.fov)
        filepath = processor.dst_filepath(
            dst_root=current_app.config.get('opencell_microscopy_root'),
            roi_id=roi_id,
            channel=channel,
            kind='crop',
            ext='jpg')

        file = send_file(
            open(filepath, 'rb'),
            as_attachment=True,
            attachment_filename=filepath.split(os.sep)[-1])

        return file



class CellLineAnnotation(Resource):

    @staticmethod
    def get_cell_line(cell_line_id):
        return (
            current_app.Session.query(models.CellLine)
            .filter(models.CellLine.id == cell_line_id)
            .one()
        )


    def get(self, cell_line_id):
        '''
        '''

        line = self.get_cell_line(cell_line_id)
        if line.annotation is not None:
            return jsonify({
                'comment': line.annotation.comment,
                'categories': line.annotation.categories,
                'client_metadata': line.annotation.client_metadata,
            })
        abort(404)


    def put(self, cell_line_id):
        '''
        '''
        data = request.get_json()
        line = self.get_cell_line(cell_line_id)
        annotation = line.annotation
        if annotation is None:
            annotation = models.CellLineAnnotation(cell_line_id=cell_line_id)

        annotation.comment = data.get('comment')
        annotation.categories = data.get('categories')
        annotation.client_metadata = data.get('client_metadata')

        try:
            db_utils.add_and_commit(
                current_app.Session,
                annotation,
                errors='raise')
        except Exception as error:
            abort(500, str(error))

        return jsonify(annotation.as_dict())


class MicroscopyFOVAnnotation(Resource):

    @staticmethod
    def get_fov(fov_id):
        return (
            current_app.Session.query(models.MicroscopyFOV)
            .filter(models.MicroscopyFOV.id == fov_id)
            .one()
        )


    def get(self, fov_id):
        '''
        '''
        fov = self.get_fov(fov_id)
        if fov.annotation is not None:
            return jsonify(fov.annotation.as_dict())
        abort(404, 'FOV %s does not have an annotation' % fov_id)


    def put(self, fov_id):

        data = request.get_json()
        fov = self.get_fov(fov_id)
        annotation = fov.annotation
        if annotation is None:
            annotation = models.MicroscopyFOVAnnotation(fov_id=fov_id)

        annotation.categories = data.get('categories')
        annotation.client_metadata = data.get('client_metadata')
        annotation.roi_position_top = data.get('roi_position_top')
        annotation.roi_position_left = data.get('roi_position_left')

        try:
            db_utils.add_and_commit(
                current_app.Session,
                annotation,
                errors='raise')
        except Exception as error:
            abort(500, str(error))

        return jsonify(annotation.as_dict())


    def delete(self, fov_id):

        fov = self.get_fov(fov_id)
        if fov.annotation is None:
            return abort(404, 'FOV %s does not have an annotation' % fov_id)

        try:
            db_utils.delete_and_commit(current_app.Session, fov.annotation)
        except Exception as error:
            abort(500, str(error))
        return ('', 204)
