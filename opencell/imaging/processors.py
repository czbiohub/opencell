import os
import re
import sys
import glob
import json
import pickle
import imageio
import skimage
import hashlib
import datetime
import tifffile

import numpy as np
import pandas as pd

from opencell import constants
from opencell.imaging import images, utils, nucleus_segmentation


class FOVProcessor:

    def __init__(
        self,
        fov_id,
        pml_id,
        parental_line_name,
        plate_id,
        well_id,
        site_num,
        target_name,
        src_type,
        raw_filepath,
        all_roi_rows
    ):

        self.fov_id = fov_id
        self.pml_id = pml_id
        self.parental_line_name = parental_line_name
        self.plate_id = plate_id
        self.well_id = well_id
        self.site_num = site_num

        # the root directory type
        # (either 'plate_microscopy' or 'raw_pipeline_microscopy')
        self.src_type = src_type

        # see set_src_roots
        self.src_roots = {}

        # the path to the raw TIFF, relative to src_root
        self.raw_filepath = raw_filepath

        # array of dicts for all ROIs cropped from the FOV
        self.all_roi_rows = all_roi_rows

        # clean up the target_name (remove slashes and dashes)
        self.target_name = self.clean_target_name(target_name)

        # create site_id from site_num
        self.site_id = 'S%02d' % int(self.site_num)


    def set_src_roots(self, plate_microscopy_dir=None, raw_pipeline_microscopy_dir=None):
        '''
        Set the absolute paths to the 'PlateMicroscopy'
        and 'raw-pipeline-microscopy' directories

        On ESS, these should be
        '/gpfsML/ML_group/PlateMicroscopy/'
        '/gpfsML/ML_group/raw-pipeline-microscopy/'
        '''
        self.src_roots = {
            'plate_microscopy': plate_microscopy_dir,
            'raw_pipeline_microscopy': raw_pipeline_microscopy_dir
        }


    @staticmethod
    def clean_target_name(target_name):
        '''
        Create a filename-safe target_name by removing slashes and dashes
        '''
        forbidden_chars = ['-', '_', '/']
        for char in forbidden_chars:
            target_name = target_name.replace(char, '')
        return target_name


    @classmethod
    def from_database(cls, fov):
        '''
        Initialize a processor given a microscopy_fov instance from opencelldb

        Note that this method assumes that fov.cell_line is an 'original' polyclonal line
        (and not, for example, a descendent generated by re-sorting an original polyclonal line
        or a clonal descendent of a polyclonal line)
        '''

        crispr_design = fov.cell_line.crispr_design

        # roi_props for all ROIs cropped from this FOV (will often be empty)
        all_roi_rows = [roi.as_dict() for roi in fov.rois]

        # get the name of the progenitor cell line
        line = fov.cell_line
        while True:
            line = line.parent
            if line.line_type.value == 'PROGENITOR':
                parental_line_name = line.name
                break

        processor = cls(
            fov_id=fov.id,
            pml_id=fov.dataset.pml_id,
            parental_line_name=parental_line_name,
            plate_id=crispr_design.plate_design_id,
            well_id=crispr_design.well_id,
            site_num=fov.site_num,
            src_type=fov.dataset.root_directory,
            raw_filepath=fov.raw_filename,
            target_name=crispr_design.target_name,
            all_roi_rows=all_roi_rows
        )

        processor.fov = fov
        return processor


    @staticmethod
    def z_step_size(pml_id):
        '''
        Unpleasant method to determine the z-step size from the PML ID

        This method encodes the facts that, prior to ML0123 (aka PML0123),
        the step size was always 0.5um, and that starting at ML0123,
        the step size has always been 0.2um.

        NOTE: this method is necessary because the z-step size is *not* encoded
        in the MicroManager metadata or anywhere else
        '''
        z_step_size = 0.2
        critical_pml_num = 123
        pml_num = int(pml_id[3:])
        if pml_num < critical_pml_num:
            z_step_size = 0.5
        return z_step_size


    def src_filepath(self):
        '''
        Construct the absolute filepath to a TIFF stack
        in either the 'PlateMicroscopy' or 'raw-pipeline-microscopy' directory
        '''

        src_root = self.src_roots.get(self.src_type) or ''
        src_filepath = os.path.join(src_root, self.raw_filepath)
        return src_filepath


    def dst_plate_dir(self):
        '''
        Construct a dst plate_dir from an src plate_dir

        Destination plate directory names are of the form 'czML0383-P0001'
        '''
        dst_plate_dir = f'{self.parental_line_name}-{self.plate_id}'
        return dst_plate_dir


    def dst_filepath(
        self,
        dst_root=None,
        kind=None,
        channel=None,
        roi_id=None,
        roi_props=None,
        roi_kind=None,
        ext=None,
        makedirs=True
    ):
        '''
        Construct the relative directory path and filename for an output file

        Directory path and filename formats:

        dst_filepath:   '{kind}/{dst_plate_dir}/{dst_filename}'
        dst_plate_dir:  'czML0383-{plate_id}'
        dst_filename:   'czML0383-{plate_id}-{well_id}-{pml_id}-S{site_num}_{appendix}'

        Appendix formats are kind-dependent:

        kind          appendix format
        -----------------------------------------------------------------
        'proj'        'PROJ-CH{channel}'
        'clean'       'CLEAN'
        'roi'         'ROI-{roi_kind}-{top_left_row}-{top_left_col}-{n_rows}-{n_cols}-CH{channel}'

        roi_kind is one of 'proj', 'hqtile', 'lqtile'

        Note that 'czML0383' is technically the name of the FOV's cell line's parental line,
        but for opencell datasets, this is always 'czML0383'.

        Here is a full example filename, for an 'roi' file:
        'czML00383-P0001-A01-PML0123-S01_ROI-HQTILE-0424-0000-0600-0600-CH405'
        '''

        if dst_root is None:
            dst_root = ''

        kinds = ['proj', 'roi', 'clean', 'segmentation']
        if kind not in kinds:
            raise ValueError('%s is not a valid destination kind' % kind)

        # retrieve the roi_props if an roi_id was provided
        if roi_id is not None:
            row = [row for row in self.all_roi_rows if row['id'] == roi_id]
            if not row:
                raise ValueError('ROI %s is not an ROI of FOV %s' % (roi_id, self.fov_id))
            roi_props = row[0]['props']

        # construct the filename appendix, starting from `kind`
        appendix = kind.upper()

        # append the ROI coords, which we assume correspond to
        # (top_left_row, top_left_col, num_rows, num_cols)
        if kind == 'roi':
            for coord in roi_props['xy_coords']:
                appendix = '%s-%04d' % (appendix, coord)
            appendix = '%s-%s' % (appendix, roi_kind.upper())

        # append the channel last, so that when sorting files,
        # the two channels of each kind of file remain adjacent to one another
        if channel is not None:
            appendix = '%s-CH%s' % (appendix, channel)

        # destination plate_dir name
        dst_plate_dir = self.dst_plate_dir()

        # construct the destination dirpath
        dst_dirpath = os.path.join(dst_root, kind, dst_plate_dir)
        if makedirs:
            os.makedirs(dst_dirpath, exist_ok=True)

        # construct the destination filename
        dst_filename = (
            f'{dst_plate_dir}-{self.well_id}-{self.pml_id}-{self.site_id}_{appendix}.{ext}'
        )
        return os.path.join(dst_dirpath, dst_filename)


    def load_raw_tiff(self):
        '''
        Convenience method to open and parse a raw TIFF and attempt to split it by channel
        Returns None if the file does not exist or cannot be split by channel
        '''
        src_filepath = self.src_filepath()
        if os.path.isfile(src_filepath):
            tiff = images.RawPipelineTIFF(src_filepath, verbose=False)
            tiff.parse_micromanager_metadata()
            tiff.validate_micromanager_metadata()
            tiff.split_channels()
            if tiff.did_split_channels:
                return tiff
            else:
                print('Warning: could not split the TIFF')
                tiff.tiff.close()


    def process_raw_tiff(self, dst_root):
        '''
        Process a single raw TIFF
            1) parse the micromanager and other metadata
            2) split the tiff pages into the z-stacks for the 405 and 488 channels
            3) generate z-projections

        dst_root : the path to the destination 'opencell-microscopy' directory

        NOTE: the `tiff.global_metadata` object returned by this method
        is modified by all of the `RawPipelineTIFF` methods called below
        (including by `project_stack`, which appends the min/max intensities)
        '''

        src_filepath = self.src_filepath()
        metadata = {'src_filepath': src_filepath}
        if not os.path.isfile(src_filepath):
            metadata['error'] = 'File does not exist'

        tiff = images.RawPipelineTIFF(src_filepath, verbose=False)
        tiff.parse_micromanager_metadata()
        tiff.validate_micromanager_metadata()

        # attempt to split the channels and project
        tiff.split_channels()
        if tiff.did_split_channels:
            for channel in [tiff.laser_405, tiff.laser_488]:
                dst_filepath = self.dst_filepath(
                    dst_root=dst_root, kind='proj', channel=channel, ext='tif'
                )
                tiff.project_stack(channel_name=channel, axis='z', dst_filepath=dst_filepath)

        # the tiff file must be manually closed
        tiff.tiff.close()

        metadata.update(tiff.global_metadata)

        # return the parsed raw TIFF metadata and the parsing events (if any)
        result = {'metadata': metadata, 'events': tiff.events}
        return result


    def calculate_fov_features(self, dst_root, fov_scorer):
        '''
        Calculate the features and score for the FOV
        using the PipelineFOVScorer module from the dragonfly-automation project

        dst_root : the root directory in which z-projections were saved in process_raw_tiff
        fov_scorer : an instance of PipelineFOVScorer in 'training' mode
        '''

        # construct the filepath to the z-projection of the Hoechst staining
        filepath = self.dst_filepath(dst_root, kind='proj', channel='405', ext='tif')
        result = fov_scorer.process_existing_fov(filepath)
        return result


    @staticmethod
    def generate_thumbnail(im, scale, quality):
        '''
        '''
        # use downscale_local_mean to reduce noise
        im = skimage.transform.downscale_local_mean(im, factors=(scale, scale, 1))

        # crop the last row and column to eliminate edge effects
        im = im[:-1, :-1, :]

        # cast to uint8 again (downscale_local_mean outputs float64)
        im = utils.autoscale(im)

        # base64 encode
        encoded_im = utils.b64encode_image(im, format='jpg', quality=quality)
        return encoded_im


    def generate_fov_thumbnails(self, dst_root, scale, quality):
        '''
        Generate thumbnail images of the z-projections as base64-encoded JPGs
        '''
        filepath_405 = self.dst_filepath(dst_root, kind='proj', channel='405', ext='tif')
        filepath_488 = self.dst_filepath(dst_root, kind='proj', channel='488', ext='tif')

        ims = {}
        ims['405'] = tifffile.imread(filepath_405)[..., None]
        ims['488'] = tifffile.imread(filepath_488)[..., None]
        ims['rgb'] = self.make_rgb(ims['405'], ims['488'])

        encoded_ims = {}
        for channel, im in ims.items():
            encoded_ims[channel] = self.generate_thumbnail(im, scale, quality)

        result = {
            'size': im.shape[0],
            'quality': quality,
            'encoded_ims': encoded_ims,
        }
        return result


    def generate_nucleus_segmentation(self, dst_root):
        '''
        Generate nucleus segmentation mask from the z-projection of the 405 channel
        '''
        filepath = self.dst_filepath(dst_root, kind='proj', channel='405', ext='tif')
        im = tifffile.imread(filepath)
        mask = nucleus_segmentation.generate_final_mask(im)

        result = None
        dst_filepath = self.dst_filepath(dst_root, kind='segmentation', ext='tif')
        tifffile.imsave(dst_filepath, (255*mask).astype('uint8'), dtype='uint8')
        return result


    def generate_annotated_roi_thumbnails(self, dst_root, scale, quality):
        '''
        Generate thumbnail images of the annotated ROI for the FOV (if any)
        '''

        # check that the FOV is annotated
        if not self.fov.annotation:
            return None

        # hack: check that an annotated ROI exists, and get the roi_id,
        # by using the fact that the only ROIs that exist are annotated ROIs
        # (some annotated FOVs may not have an ROI, if they could not be cropped in z)
        if not self.fov.rois:
            return None
        roi_id = self.fov.rois[0].id

        roi_size = 600
        top, left = self.fov.annotation.roi_position_top, self.fov.annotation.roi_position_left

        filepath_405 = self.dst_filepath(dst_root, kind='proj', channel='405', ext='tif')
        filepath_488 = self.dst_filepath(dst_root, kind='proj', channel='488', ext='tif')

        ims = {}
        ims['405'] = (
            tifffile.imread(filepath_405)
            [top:(top + roi_size), left:(left + roi_size), None]
        )
        ims['488'] = (
            tifffile.imread(filepath_488)
            [top:(top + roi_size), left:(left + roi_size), None]
        )
        ims['rgb'] = self.make_rgb(ims['405'], ims['488'])

        encoded_ims = {}
        for channel, im in ims.items():
            encoded_ims[channel] = self.generate_thumbnail(im, scale, quality)

        result = {
            'roi_id': roi_id,
            'size': im.shape[0],
            'quality': quality,
            'encoded_ims': encoded_ims,
        }
        return result


    def calculate_z_profiles(self):
        '''
        '''
        # attempt to load and split the TIFF
        result = {}
        tiff = self.load_raw_tiff()
        if tiff is None:
            result['error'] = 'Raw TIFF file for fov %s does not exist' % self.fov_id
            return result

        for channel in (tiff.laser_405, tiff.laser_488):
            try:
                result[channel] = tiff.calculate_z_profiles(tiff.stacks[channel])
            except Exception as error:
                result[channel] = {'error': str(error)}
        return result


    def generate_clean_tiff(self, dst_root):
        '''
        Generate 'clean' but otherwise raw TIFFs for machine-learning pipelines by
            1) aligning the two channels to approximately correct for chromatic aberration in z
            2) centering and cropping the stacks around the cell layer in z
            3) downsampling stacks with 0.2um z-steps to 0.5um z-steps
        '''

        # the z-position of the top and bottom of the cell layer,
        # relative to the cell layer center, in microns
        cell_layer_bottom = -5
        cell_layer_top = 6

        # the desired step size of the clean TIFFs in um
        target_step_size = 0.5

        result = {}
        tiff = self.load_raw_tiff()
        if tiff is None:
            result['error'] = 'Raw TIFF file for fov %s does not exist' % self.fov_id
            return result

        step_size = self.z_step_size(self.pml_id)
        try:
            stacks, result = tiff.align_cell_layer(cell_layer_bottom, cell_layer_top, step_size)
        except Exception as error:
            result['error'] = str(error)

        # check if an error occurred above or in crop_and_align_cell_layer
        if result.get('error'):
            return result

        # if the step_size is 0.2um, downsample to 0.5um
        # (assumes that step_size is only ever 0.2um or 0.5um)
        if step_size == 0.2:
            zscale = step_size/target_step_size
            for channel in stacks:
                stacks[channel] = skimage.transform.rescale(
                    stacks[channel],
                    scale=(zscale, 1, 1),
                    multichannel=False,
                    preserve_range=True,
                    anti_aliasing=False,
                    order=1
                )
                stacks[channel] = stacks[channel].astype('uint16')

        # save the stacks as a hyperstack in CZXY order
        stack = np.concatenate((stacks['405'][None, :], stacks['488'][None, :]), axis=0)
        dst_filepath = self.dst_filepath(dst_root, kind='clean', ext='tif')
        tifffile.imsave(dst_filepath, stack, dtype='uint16')

        result['final_stack_shape'] = stack.shape
        return result


    def crop_corner_rois(self, dst_root):
        '''
        '''
        fov_size = 1024
        roi_size = 600
        min_coord = 0
        max_coord = fov_size - roi_size
        roi_top_left_positions = [
            (min_coord, min_coord),
            (min_coord, max_coord),
            (max_coord, min_coord),
            (max_coord, max_coord),
        ]
        return self._crop_rois(dst_root, roi_size, roi_top_left_positions)


    def crop_annotated_roi(self, dst_root):
        '''
        Crop the manually annotated ROI (assumes an annotation exists)
        '''

        roi_size = 600
        roi_top_left_positions = [
            (
                self.fov.annotation.roi_position_top,
                self.fov.annotation.roi_position_left,
            )
        ]
        return self._crop_rois(dst_root, roi_size, roi_top_left_positions)


    def _crop_rois(self, dst_root, roi_size, roi_top_left_positions):
        '''
        Crop one or more ROIs from the cell-layer-cropped z-stacks,
        downsample the intensities from uint16 to uint8, and save each ROI as a tiled PNG

        Arguments
        ---------
        dst_root :
        roi_size : the size of the ROI to crop (usually 600x600)
        roi_top_left_positions : the position of the top left corner of each ROI
            (as a list of (row, column) tuples)

        Returns
        -------
        error_info : a dict with an 'error' key if an error occured
        all_roi_props : a list of ROI properties (empty if an error ocurred)

        '''

        result = {}
        all_roi_props = []

        # attempt to load and split the TIFF
        tiff = self.load_raw_tiff()
        if tiff is None:
            result['error'] = 'Raw TIFF file for fov %s does not exist' % self.fov_id
            return result, all_roi_props

        # the top and bottom of the cell layer, relative to its center, in microns
        # (these were empirically determined)
        cell_layer_bottom = -5
        cell_layer_top = 6

        # wiggle room for the cell layer bottom (in microns)
        bottom_wiggle_room = 1

        # the desired step size of the final stack in microns
        # (this is chosen to correspond to the xy pixel size,
        # so that the voxels of the resampled stack will be isotropic)
        target_step_size = 0.4

        # the step size of the raw data
        original_step_size = self.z_step_size(self.pml_id)

        # the number of slices the resampled stack must have
        # this should be equal to, or rounded down from, (rel_top - rel_buttom) / target_step_size
        required_num_slices = 27

        # crop (and maybe pad) around the cell layer in z
        aligned_stacks, alignment_result = tiff.align_cell_layer(
            cell_layer_bottom,
            cell_layer_top,
            step_size=original_step_size,
            bottom_wiggle_room=bottom_wiggle_room
        )

        result['cell_layer_top'] = cell_layer_top
        result['cell_layer_bottom'] = cell_layer_bottom
        result['bottom_wiggle_room'] = bottom_wiggle_room
        result['alignment_result'] = alignment_result

        # if an alignment error occured, log it and do not continue
        # (these errors occur when the cell layer center was too close
        # to the top or bottom of the z-stack)
        if alignment_result.get('error'):
            result['error'] = 'An error ocurred in align_cell_layer'
            return result, all_roi_props

        # for now, the ROIs span the full extent of the cell-layer-cropped stack
        min_z_ind = 0
        max_z_ind = aligned_stacks['405'].shape[0]

        # the shape of each ROI
        roi_shape = (roi_size, roi_size, max_z_ind - min_z_ind)

        # append the z-position to the ROI positions
        roi_top_left_positions = [(*pos, min_z_ind) for pos in roi_top_left_positions]

        for roi_position in roi_top_left_positions:
            roi_props = {
                'shape': roi_shape,
                'position': roi_position,
                'xy_coords': (*roi_position[:2], *roi_shape[:2]),
                'target_step_size': target_step_size,
                'original_step_size': original_step_size,
                'required_num_slices': required_num_slices,
            }
            # crop the ROI
            roi, roi_props = self._crop_roi(roi_props, aligned_stacks)

            # save the ROI
            roi_props = self._save_roi(roi, roi_props, dst_root)

            all_roi_props.append(roi_props)

        return result, all_roi_props


    def _crop_roi(self, roi_props, stacks):
        '''
        Crop an ROI from the raw TIFF, resample it in z if necessary,
        and downsample it from uint16 to uint8
        '''

        num_rows, num_cols, num_z = roi_props['shape']
        row_ind, col_ind, z_ind = roi_props['position']

        roi = {}
        for channel in ['405', '488']:

            # crop the ROI from the raw stack
            cropped_stack = stacks[channel][
                z_ind:(z_ind + num_z),
                row_ind:(row_ind + num_rows),
                col_ind:(col_ind + num_cols)
            ]

            # move the z dimension from the first to the last axis
            cropped_stack = np.moveaxis(cropped_stack.copy(), 0, -1)

            # resample the stack in z so it has the required step size and number of z-slices
            cropped_stack, did_resample_stack = self.maybe_resample_stack(
                cropped_stack,
                original_step_size=roi_props['original_step_size'],
                target_step_size=roi_props['target_step_size'],
                required_num_slices=roi_props['required_num_slices']
            )

            # the did_resample_stack flag will always be the same for both channels
            roi_props['stacks_resampled'] = did_resample_stack

            # downsample the pixel intensities from uint16 to uint8
            cropped_stack, min_intensity, max_intensity = self.stack_to_uint8(
                cropped_stack, percentile=0.01
            )

            # log the black and white points used to downsample the intensities
            roi_props['min_intensity_%s' % channel] = min_intensity
            roi_props['max_intensity_%s' % channel] = max_intensity

            # smooth the hoechst channel slightly to reduce the tiled JPG filesize
            if channel == '405':
                cropped_stack = skimage.filters.gaussian(
                    cropped_stack, sigma=(.5, .5, .5), preserve_range=True
                )
                cropped_stack = cropped_stack.astype('uint8')

            roi[channel] = cropped_stack
        return roi, roi_props


    def _save_roi(self, roi, roi_props, dst_root):
        '''
        Save an ROI generated by _crop_roi as a one-dimensional tiled array of z-slices

        Note that this method includes hand-picked optimizations
        to minimize the filesize of the tiled JPGs that are specific to ROIs
        that are uint8 arrays of shape (600, 600, 27) (or something close to that)
        '''
        # common args for the dst_filepath method
        common_args = dict(
            dst_root=dst_root,
            kind='roi',
            roi_props=roi_props,
            ext='jpg'
        )

        tile = {}
        for channel, stack in roi.items():

            # save the z-projection
            proj = stack.max(axis=-1)
            dst_filepath = self.dst_filepath(roi_kind='proj', channel=channel, **common_args)
            imageio.imsave(dst_filepath, proj, format='jpg', quality=95)

            # reshape the ROI stacks into a one-dimensional tiled array of z-slices
            stack = np.moveaxis(stack, -1, 0)
            tile[channel] = np.concatenate([zslice for zslice in stack], axis=0)

        # for high-quality hoechst, use a fixed JPG quality of 90%
        channel = '405'
        jpg_quality = 90
        dst_filepath = self.dst_filepath(roi_kind='hqtile', channel=channel, **common_args)
        imageio.imsave(dst_filepath, tile[channel], format='jpg', quality=jpg_quality)
        roi_props['high_jpg_quality_%s' % channel] = jpg_quality

        # for low-quality hoechst, use a fixed JPG quality of 50%
        jpg_quality = 50
        dst_filepath = self.dst_filepath(roi_kind='lqtile', channel=channel, **common_args)
        imageio.imsave(dst_filepath, tile[channel], format='jpg', quality=jpg_quality)
        roi_props['low_jpg_quality_%s' % channel] = jpg_quality

        # for high-quality GFP, use the JPG quality that yields a filesize less than 4MB
        channel = '488'
        target_filesize = 4.0
        dst_filepath = self.dst_filepath(roi_kind='hqtile', channel=channel, **common_args)
        jpg_quality = self.save_jpg(
            dst_filepath, tile[channel], target_filesize, min_quality=70, max_quality=95
        )
        roi_props['high_jpg_quality_%s' % channel] = jpg_quality

        # for low-quality GFP, use the JPG quality that yields a filesize less than 1MB
        target_filesize = 1.0
        dst_filepath = self.dst_filepath(roi_kind='lqtile', channel=channel, **common_args)
        jpg_quality = self.save_jpg(
            dst_filepath, tile[channel], target_filesize, min_quality=30, max_quality=90
        )
        roi_props['low_jpg_quality_%s' % channel] = jpg_quality

        return roi_props


    @staticmethod
    def save_jpg(filepath, image, target_filesize, min_quality, max_quality):
        '''
        Save a JPG with a quality chosen to match a target filesize
        Note: this is a hackish implementation

        image : numpy array (assumed to be JPG-compatible)
        target_filesize : the desired filesize, in megabytes
        min_quality, max_quality : hard-coded bounds on the JPG quality
        '''
        jpg_qualities = range(max_quality, min_quality, -5)
        for jpg_quality in jpg_qualities:
            imageio.imsave(filepath, image, format='jpg', quality=jpg_quality)
            if os.stat(filepath).st_size/1024/1024 < target_filesize:
                break
        return jpg_quality


    @staticmethod
    def maybe_resample_stack(stack, original_step_size, target_step_size, required_num_slices):
        '''
        Resample and possibly crop or pad a z-stack
        so that it has the required number of z-slices

        stack : 3D numpy array with dimensions (x, y, z)
        original_step_size : the z-step size of the original stack (in microns)
        target_step_size : the desired z-step size after resampling (in microns)
        required_num_slices : the number of z-slices the resampled stack must have
        '''

        did_resample_stack = False

        # resample z to generate isotropic voxels
        if original_step_size != target_step_size:
            did_resample_stack = True
            z_scale = original_step_size/target_step_size
            stack = skimage.transform.rescale(
                stack,
                (1, 1, z_scale),
                multichannel=False,
                preserve_range=True,
                anti_aliasing=False,
                mode='reflect',
                order=1
            )

        # pad or crop z-slices from the end (top) of the z-stack
        # so that the stack has the required number of slices
        num_rows, num_cols, num_slices = stack.shape
        if num_slices < required_num_slices:
            pad = np.zeros(
                (num_rows, num_cols, required_num_slices - num_slices),
                dtype=stack.dtype
            )
            stack = np.concatenate((stack, pad), axis=2)
        elif num_slices > required_num_slices:
            stack = stack[:, :, :required_num_slices]

        return stack, did_resample_stack


    @staticmethod
    def stack_to_uint8(stack, percentile):
        '''
        Downsample the raw uint16 pixel intensities to uint8
        and return the black and white points used to do so
        '''

        stack = stack.astype(float)
        minn, maxx = np.percentile(stack, (percentile, 100 - percentile))
        if minn == maxx:
            maxx = minn + 1

        stack -= minn
        stack[stack < 0] = 0
        stack /= (maxx - minn)
        stack[stack > 1] = 1

        stack = (255*stack).astype('uint8')
        return stack, int(minn), int(maxx)


    @staticmethod
    def stack_to_tile2d(stack, num_cols):
        '''
        Transform a z-stack into a 2D array of z-slices
        (currently unused)

        stack : 3D numpy array with dimensions (x, y, z)
        num_cols : the number of columns in the tile
        '''

        num_slices = stack.shape[-1]
        num_extra_slices = int(num_cols * np.ceil(num_slices/num_cols) - num_slices)
        extra_slices = np.zeros((*stack.shape[:2], num_extra_slices), dtype=stack.dtype)
        stack = np.concatenate((stack, extra_slices), axis=2)

        num_slices = stack.shape[-1]
        num_rows = int(num_slices/num_cols)

        rows = []
        for row_ind in range(num_rows):
            row = np.concatenate(
                [stack[:, :, col_ind + row_ind*num_cols] for col_ind in range(num_cols)], axis=1
            )
            rows.append(row)
        tile = np.concatenate(rows, axis=0)

        return tile


    @staticmethod
    def make_rgb(im_405, im_488):
        '''
        Construct an RGB image from z-projections (or single z-slices) of each channel
        im_405 : 2D numpy array (assumed to be the Hoechst staining)
        im_488 : 2D numpy array (assumed to be the GFP signal)
        '''

        if im_405.ndim == 2:
            im_405 = im_405[..., None]
        if im_488.ndim == 2:
            im_488 = im_488[..., None]

        # background subtract the hoechst
        im_405 = im_405.astype(float)
        im_405 -= im_405.mean()
        im_405[im_405 < 0] = 0

        # downscale to uint8 using 1% percentiles
        # (and bump the gamma for hoechst to make it stand out again the GFP a bit better)
        hoechst = utils.autoscale(im_405, percentile=1, gamma=.7)
        gfp = utils.autoscale(im_488, percentile=1)

        # set the blue channel to the maximum of the GFP and hoechst
        # (this is easier than summing the channels and dealing with uint8 overflow, etc)
        blue = np.concatenate((gfp, hoechst), axis=2).max(axis=2)[..., None]

        red, green = gfp, gfp
        rgb = np.concatenate((red, green, blue), axis=2)
        return rgb
