import os
import re
import enum
import json
import numpy as np
import pandas as pd
import sqlalchemy as db

from opencell import constants
from opencell.database import models, utils, uniprot_utils


def get_or_create_progenitor_cell_line(session, name, notes=None, create=False):
    '''
    Get or create a progenitor cell line by manual entry

    'Progenitor' cell lines are strictly those used for electroporations;
    they are therefore the root nodes in the self-referential cell_line table
    (which contains predominately polyclonal and monoclonal lines).

    The use of a human-readable name here is just for convenience and is intended
    to facilitate the creation/retrieval of the progenitor cell lines used for electroporation
    (of which we can assume there will be very few).

    Parameters
    ----------
    name : required human-readable and unique name for the cell_line
    notes : optional human-readable notes about the cell line
    create : whether to create a cell line with the given name if one does not already exist

    Returns
    -------
    A CellLine instance corresponding to the progenitor cell line

    '''

    # check whether the progenitor cell line already exists
    cell_line = (
        session.query(models.CellLine)
        .filter(models.CellLine.name == name)
        .one_or_none()
    )
    if cell_line is not None and create:
        print("Warning: a cell line with the name '%s' already exists" % name)
    elif cell_line is None and create:
        print("Creating progenitor cell line with name '%s'" % name)
        cell_line = models.CellLine(name=name, notes=notes, line_type='PROGENITOR')
        utils.add_and_commit(session, cell_line, errors='raise')
    elif cell_line is None:
        print("Warning: a progenitor cell line with name '%s' does not exist" % name)

    return cell_line


def get_or_create_plate_design(session, design_id, date=None, notes=None, create=False):
    '''
    Get or create a new plate design
    note that date and notes may be None
    '''

    plate_design = (
        session.query(models.PlateDesign)
        .filter(models.PlateDesign.design_id == design_id)
        .one_or_none()
    )
    if create and plate_design is not None:
        print('Warning: plate design %s already exists' % design_id)

    if plate_design is None:
        if create:
            plate_design = models.PlateDesign(
                design_id=design_id, design_date=date, design_notes=notes
            )
            utils.add_and_commit(session, plate_design, errors='warn')
        else:
            raise ValueError('plate_design %s does not exist')

    return plate_design


def create_crispr_designs(
    session,
    plate_design,
    library_snapshot,
    drop_existing=False,
    errors='warn'
):
    '''
    Insert all crispr designs for a given plate design,
    using a snapshot of the library spreadsheet.

    Parameters
    ----------
    session : sqlalchemy session
    plate_design : PlateDesign instance corresponding to the plate
        whose crispr designs are to be inserted
    library_snapshot : a snapshot of the library spreadsheet as a pandas dataframe
    drop_existing : whether to drop any existing crispr designs linked to this plate
    '''

    # crop the library to the current plate
    designs = library_snapshot.loc[
        library_snapshot.plate_id == plate_design.design_id
    ].copy()

    # discard the plate_id
    designs.drop(labels=['plate_id'], axis=1, inplace=True)

    # coerce nan to None (sqlalchemy doesn't coerce np.nan to NULL)
    designs.replace({pd.np.nan: None}, inplace=True)

    # check that we have the expected number of designs/wells
    if designs.shape[0] != len(constants.DATABASE_WELL_IDS):
        print('Warning: %s crispr designs found but 96 are expected' % designs.shape[0])

    # drop the negative (empty) controls
    designs = designs.loc[designs.target_name != 'empty_control']

    # delete all existing crispr designs
    if drop_existing:
        utils.delete_and_commit(session, plate_design.crispr_designs)

    # create the crispr designs and insert them one by one
    # (so that an insertion error on one design doesn't prevent attempting to insert the others)
    for _, design in designs.iterrows():
        print('Inserting design for well %s on plate %s' % (design.well_id, plate_design.design_id))
        plate_design.crispr_designs.append(models.CrisprDesign(**design))
        utils.add_and_commit(session, plate_design, errors=errors)


def create_polyclonal_lines(
    session,
    progenitor_cell_line,
    plate_design,
    date,
    errors='warn'
):
    '''
    Create the initial polyclonal lines generated by electroporating a single plate

    Parameters
    ----------
    progenitor_cell_line : the CellLine instance corresponding to the electroporated cell line
    plate_design : the PlateDesign instance corresponding to the electroporated plate
    date : the date, as a string, of the electroporation
            (required to disambiguate electroporations of the same plate)
    '''

    line_type = 'POLYCLONAL'

    # sort count is always 1 for the initial sort after electroporation
    sort_count = 1

    for crispr_design in plate_design.crispr_designs:

        # check for an existing polyclonal line associated with this crispr design
        # this is necessary because it is not currently possibly to define a unique constraint on
        # (progenitor_line_id, crispr_design_id, sort_count) in the cell line table,
        # because sort_count is nullable (in anticipation of adding monoclonal lines)
        existing_line = (
            session.query(models.CellLine)
            .filter(models.CellLine.parent_id == progenitor_cell_line.id)
            .filter(models.CellLine.line_type == line_type)
            .filter(models.CellLine.crispr_design_id == crispr_design.id)
            .filter(models.CellLine.sort_count == sort_count)
            .one_or_none()
        )

        if existing_line:
            print(
                'Warning: a polyclonal cell line already exists for (%s, %s)'
                % (plate_design.design_id, crispr_design.well_id)
            )
            continue

        cell_line = models.CellLine(
            parent_id=progenitor_cell_line.id,
            crispr_design=crispr_design,
            line_type=line_type,
            sort_count=sort_count,
            sort_date=date
        )
        utils.add_and_commit(session, cell_line, errors=errors)


def get_lines_by_annotation(engine, annotation):
    '''
    Get the ids of all cell lines with a particular manual annotation category
    '''
    result = pd.read_sql(
        f'''
        select cell_line_id from(
            select cell_line_id, json_array_elements_text(categories::json) as cat
            from cell_line_annotation
        ) tmp
        where cat = '{annotation}'
        ''',
        engine
    )
    return result.cell_line_id.tolist()


class PolyclonalLineOperations:
    '''
    Methods to retrieve and insert datasets that are associated with a single polyclonal line
    '''

    def __init__(self, line):
        self.line = line


    @classmethod
    def from_line_id(cls, session, line_id, eager=False):
        '''
        '''
        query = session.query(models.CellLine)
        if eager:
            query = query.options(
                db.orm.joinedload(models.CellLine.fovs, innerjoin=True)
                .joinedload(models.MicroscopyFOV.results, innerjoin=True)
            )
        return cls(query.get(line_id))


    @classmethod
    def from_plate_well(cls, session, design_id, well_id, sort_count):
        '''
        Convenience method to retrieve the cell line
        corresponding to a plate design and a well id
        (assuming that there is only one such cell line)

        sort_count : 1 for the original polyclonal line
               2 for the resorted descendent (if any)
               3 for the resort of the resort (if any)
        '''

        lines = (
            session.query(models.CellLine)
            .join(models.CrisprDesign)
            .filter(models.CrisprDesign.plate_design_id == design_id)
            .filter(models.CrisprDesign.well_id == well_id)
            .filter(models.CellLine.sort_count == sort_count)
            .all()
        )

        if not lines:
            raise ValueError(
                "No cell line exists with a sort_count of %s for well %s of plate %s"
                % (sort_count, well_id, design_id)
            )

        if len(lines) > 1:
            raise ValueError(
                "More than one cell line exists with a sort_count of %s for well %s of plate %s"
                % (sort_count, well_id, design_id)
            )

        return cls(lines[0])


    @classmethod
    def from_target_name(cls, session, target_name):
        '''
        Convenience method to retrieve the cell line for the given target_name

        If there is more than one cell_line for the target_name,
        then the PolyClonalLineOperations class is instantiated using the first such cell_line
        '''

        lines = (
            session.query(models.CellLine)
            .join(models.CrisprDesign)
            .filter(db.func.lower(models.CrisprDesign.target_name) == db.func.lower(target_name))
            .all()
        )

        if len(lines) > 1:
            print(
                'Warning: returning the first of %s cell lines found for target_name %s' %
                (len(lines), target_name)
            )
        if not lines:
            raise ValueError("No cells lines found for target name '%s'" % target_name)

        return cls(lines[0])


    def insert_facs_dataset(self, session, histograms, scalars, errors='warn'):
        '''
        Insert the processed FACS data for a single polyclonal cell line
        '''

        # drop any existing data
        if self.line.facs_dataset:
            utils.delete_and_commit(session, self.line.facs_dataset)

        facs_dataset = models.FACSDataset(
            cell_line=self.line,
            scalars=utils.to_jsonable(scalars),
            histograms=utils.to_jsonable(histograms)
        )
        utils.add_and_commit(session, facs_dataset, errors=errors)


    def insert_sequencing_dataset(self, session, scalars, errors='warn'):
        '''
        Insert a limited set of the sequencing results - just the HDR/all and HDR/modified ratios
        '''

        # drop any existing data
        if self.line.sequencing_dataset:
            utils.delete_and_commit(session, self.line.sequencing_dataset)

        sequencing_dataset = models.SequencingDataset(
            cell_line=self.line,
            scalars=utils.to_jsonable(scalars)
        )
        utils.add_and_commit(session, sequencing_dataset, errors=errors)


    def insert_microscopy_fovs(self, session, metadata, errors='warn'):
        '''
        Insert a set of microscopy FOVs for the cell line

        metadata : dataframe of raw FOV metadata with the following columns:
        pml_id, imaging_round_id, site_num, raw_filepath
        '''

        fovs = self.line.fovs
        for _, row in metadata.iterrows():
            fov = models.MicroscopyFOV(
                cell_line=self.line,
                pml_id=row.pml_id,
                site_num=row.site_num,
                raw_filename=row.raw_filepath,
                imaging_round_id=row.imaging_round_id,
            )
            fovs.append(fov)
        utils.add_and_commit(session, fovs, errors=errors)
