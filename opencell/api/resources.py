import os
import urllib
import pandas as pd
import sqlalchemy as db

from flask_restful import Resource, reqparse
from flask import (
    current_app, 
    jsonify, 
    request,
    send_file,
    abort
)

from opencell.imaging.processors import FOVProcessor
from opencell.database import models, operations
from opencell.api.cache import cache


# copied from https://stackoverflow.com/questions/24816799/how-to-use-flask-cache-with-flask-restful
def cache_key():
   args = request.args
   key = request.path + '?' + urllib.parse.urlencode([
     (k, v) for k in sorted(args) for v in sorted(args.getlist(k))
   ])
   return key


class Plates(Resource):

    def get(self):
        '''
        All plate designs/instances
        '''
        raise NotImplementedError

    def post(self):
        '''
        Create a new plate design or instance
        '''
        raise NotImplementedError


class Plate(Resource):

    def get(self, plate_id):
        '''
        Get a plate design by design_id

        TODO: handle invalid plate_id (what error code to return?)
        '''
        plate = current_app.Session.query(models.PlateDesign)\
            .filter(models.PlateDesign.design_id == plate_id)\
            .first()

        targets = [d.target_name for d in plate.crispr_designs]
        
        return {
            'plate_id': plate.design_id,
            'targets': targets,
        }

    
    def put(self, plate_id):
        '''
        Modify an existing plate design or instance
        '''
        raise NotImplementedError


class Electroporations(Resource):

    def get(self):
        '''
        Show all extant electroporations
        '''
        eps = current_app.Session.query(models.Electroporation).all()

        eps = [{
                'date': str(ep.electroporation_date), 
                'plate_id': ep.plate_instance.plate_design_id
            } for ep in eps]

        eps = sorted(eps, key=lambda d: d['plate_id'])
        return eps


    def post(self):
        '''
        Create a new electroporation
        '''
        raise NotImplementedError


class PolyclonalLines(Resource):

    @cache.cached(timeout=3600, key_prefix=cache_key)
    def get(self):
        '''
        All polyclonal lines 
        (that is, all lines directly generated by an electroporation)
        '''

        args = request.args
        kind = args.get('kind')
        plate_id = args.get('plate_id')
        target_name = args.get('target_name')

        if kind is not None and kind not in ['all', 'facs', 'sequencing', 'ms', 'microscopy']:
            # TODO: return the right http error
            pass
        
        designs = None
        if target_name:
        
            # first look for an exact match
            designs = current_app.Session.query(models.CrisprDesign)\
                    .filter(db.func.lower(models.CrisprDesign.target_name) == target_name.lower()).all()
    
            # if no exact matches, use startswith
            if not designs:
                designs = current_app.Session.query(models.CrisprDesign)\
                    .filter(db.func.lower(models.CrisprDesign.target_name)\
                    .startswith(target_name.lower())).all()

            # filter by plate_id
            if plate_id:
                designs = [design for design in designs if design.plate_design_id == plate_id]

        # if a plate_id but not target_name was provided
        elif plate_id:
            designs = current_app.Session.query(models.CrisprDesign)\
                    .filter(models.CrisprDesign.plate_design_id == plate_id).all()
            
        lines = []
        if designs is not None:
            for design in designs:
                ep_lines = design.plate_design.plate_instances[0].electroporations[0].electroporation_lines
                cell_lines = [line.cell_line for line in ep_lines if line.well_id == design.well_id]
                lines.append(cell_lines[0])

        # all polyclonal lines
        else:
            eps = current_app.Session.query(models.Electroporation).all()
            for ep in eps:
                lines.extend([ep_line.cell_line for ep_line in ep.electroporation_lines])

        # limit to the first ten lines to prevent returning giant payloads
        if kind is not None:
            lines = lines[:10] if len(lines) > 10 else lines
    
        data = []
        for line in lines:
            ops = operations.PolyclonalLineOperations.from_line_id(current_app.Session, line.id)
            data.append(ops.construct_json(kind=kind))
        return jsonify(data)


class PolyclonalLine(Resource):

    def get(self, cell_line_id):
        '''
        '''
        args = request.args
        kind = args.get('kind')
        ops = operations.PolyclonalLineOperations.from_line_id(current_app.Session, cell_line_id)
        return jsonify(ops.construct_json(kind=kind))


class MicroscopyFOV(Resource):

    def get(self, fov_id, channel, kind):
        '''
        Return the specified kind of processed data
        for a single FOV using Flask's send_file method

        Currently, only works for kind = 'proj'
        '''

        if kind == 'proj':
            ext = 'tif'
            
        fov = current_app.Session.query(models.MicroscopyFOV)\
            .filter(models.MicroscopyFOV.id == fov_id).first()

        if not fov:
            # this means the fov_id was not valid
            # TODO: return 404?
            pass

        processor = FOVProcessor.from_database(fov)
        filepath = processor.dst_filepath(
            dst_root=current_app.config.get('opencell_microscopy_root'), 
            kind=kind, 
            channel=channel, 
            ext=ext)
    
        file = send_file(
            open(filepath, 'rb'),
            as_attachment=True, 
            attachment_filename=filepath.split(os.sep)[-1])

        return file


class MicroscopyFOVROI(Resource):

    def get(self, roi_id, channel, kind):
        '''
        Get the stack for a given roi_id as a tiled PNG

        Note that, for now, `kind` is hard-coded

        '''

        roi = current_app.Session.query(models.MicroscopyFOVROI)\
            .filter(models.MicroscopyFOVROI.id == roi_id).first()

        processor = FOVProcessor.from_database(roi.fov)
        filepath = processor.dst_filepath(
            dst_root=current_app.config.get('opencell_microscopy_root'),
            roi_id=roi_id,
            channel=channel,
            kind='crop', 
            ext='png')

        file = send_file(
            open(filepath, 'rb'),
            as_attachment=True, 
            attachment_filename=filepath.split(os.sep)[-1])

        return file


class CellLineAnnotation(Resource):

    def get(self, cell_line_id):
        '''
        '''

        line = current_app.Session.query(models.CellLine)\
            .filter(models.CellLine.id == cell_line_id).first()

        if line.annotation is not None:
            return jsonify({
                'comment': line.annotation.comment, 
                'categories': line.annotation.categories,
                'client_metadata': line.annotation.client_metadata,
            })

        abort(404)


    def put(self, cell_line_id):
        '''
        '''
        data = request.get_json()

        line = current_app.Session.query(models.CellLine)\
            .filter(models.CellLine.id == cell_line_id).first()

        annotation = line.annotation    
        if annotation is None:
            annotation = models.CellLineAnnotation(cell_line_id=cell_line_id)
        
        annotation.comment = data.get('comment')
        annotation.categories = data.get('categories')
    
        annotation.client_metadata = {
            'last_modified': data.get('timestamp'),
            'displayed_fov_ids': data.get('fov_ids'),
        }

        try:
            operations.add_and_commit(
                current_app.Session,
                annotation,
                errors='raise')
        except Exception as error:
            abort(500, str(error))  
      
        return jsonify(annotation.as_dict())