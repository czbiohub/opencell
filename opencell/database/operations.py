import os
import re
import enum
import json
import numpy as np
import pandas as pd
import sqlalchemy as db

from opencell import constants
from opencell.database import models, utils, uniprot_utils


def get_or_create_progenitor_cell_line(session, name, notes=None, create=False):
    '''
    Get or create a progenitor cell line by manual entry

    'Progenitor' cell lines are strictly those used for electroporations;
    they are therefore the root nodes in the self-referential cell_line table
    (which contains predominately polyclonal and monoclonal lines).

    The use of a human-readable name here is just for convenience and is intended
    to facilitate the creation/retrieval of the progenitor cell lines used for electroporation
    (of which we can assume there will be very few).

    Parameters
    ----------
    name : required human-readable and unique name for the cell_line
    notes : optional human-readable notes about the cell line
    create : whether to create a cell line with the given name if one does not already exist

    Returns
    -------
    A CellLine instance corresponding to the progenitor cell line

    '''

    # check whether the progenitor cell line already exists
    cell_line = (
        session.query(models.CellLine)
        .filter(models.CellLine.name == name)
        .one_or_none()
    )
    if cell_line is not None:
        print("Warning: a cell line with the name '%s' already exists" % name)
    elif create:
        print("Creating progenitor cell line with name '%s'" % name)
        cell_line = models.CellLine(name=name, notes=notes, line_type='PROGENITOR')
        utils.add_and_commit(session, cell_line, errors='raise')
    else:
        cell_line = None
        print("A progenitor cell line with name '%s' does not exist" % name)

    return cell_line


def get_or_create_plate_design(session, design_id, date=None, notes=None, create=False):
    '''
    Get or create a new plate design
    note that date and notes may be None
    '''

    plate_design = (
        session.query(models.PlateDesign)
        .filter(models.PlateDesign.design_id == design_id)
        .one_or_none()
    )
    if plate_design is None:
        if create:
            plate_design = models.PlateDesign(
                design_id=design_id, design_date=date, design_notes=notes
            )
            utils.add_and_commit(session, plate_design, errors='warn')
        else:
            raise ValueError('plate_design %s does not exist')

    return plate_design


def create_crispr_designs(
    session,
    plate_design,
    library_snapshot,
    drop_existing=False,
    errors='warn'
):
    '''
    Insert all crispr designs for a given plate design,
    using a snapshot of the library spreadsheet.

    Parameters
    ----------
    session : sqlalchemy session
    plate_design : PlateDesign instance corresponding to the plate
        whose crispr designs are to be inserted
    library_snapshot : a snapshot of the library spreadsheet as a pandas dataframe
    drop_existing : whether to drop any existing crispr designs linked to this plate
    '''

    # crop the library to the current plate
    designs = library_snapshot.loc[
        library_snapshot.plate_id == plate_design.design_id
    ].copy()

    # discard the plate_id
    designs.drop(labels=['plate_id'], axis=1, inplace=True)

    # coerce nan to None (sqlalchemy doesn't coerce np.nan to NULL)
    designs.replace({pd.np.nan: None}, inplace=True)

    # check that we have the expected number of designs/wells
    if designs.shape[0] != len(constants.DATABASE_WELL_IDS):
        raise ValueError('%s crispr designs found but 96 are expected' % designs.shape[0])

    # drop the negative (empty) controls
    designs = designs.loc[designs.target_name != 'empty_control']

    # delete all existing crispr designs
    if drop_existing:
        utils.delete_and_commit(session, plate_design.crispr_designs)

    # create the crispr designs
    for _, design in designs.iterrows():
        plate_design.crispr_designs.append(models.CrisprDesign(**design))
    utils.add_and_commit(session, plate_design, errors=errors)


def create_polyclonal_lines(
    session,
    progenitor_cell_line,
    plate_design,
    date,
    errors='warn'
):
    '''
    Create the polyclonal lines generated by electroporating a single plate

    Parameters
    ----------
    progenitor_cell_line : the CellLine instance corresponding to the electroporated cell line
    plate_design : the PlateDesign instance corresponding to the electroporated plate
    date : the date, as a string, of the electroporation
            (required to disambiguate electroporations of the same plate)
    '''

    electroporation = models.Electroporation(
        progenitor_cell_line=progenitor_cell_line,
        plate_design=plate_design,
        date_performed=date
    )

    # create a polyclonal line for each crispr design
    for crispr_design in plate_design.crispr_designs:
        cell_line = models.CellLine(
            parent_id=progenitor_cell_line.id,
            electroporation=electroporation,
            crispr_design=crispr_design,
            line_type='POLYCLONAL',
        )
        electroporation.cell_lines.append(cell_line)
    utils.add_and_commit(session, electroporation, errors=errors)


def insert_uniprot_metadata_from_id(session, uniprot_id, errors='warn'):
    '''
    Retrieve and insert Uniprot metadata for a given uniprot_id
    '''
    retrieved_metadata = uniprot_utils.query_uniprotkb(
        query=uniprot_id, only_reviewed=False, limit=1
    )

    # this is subtle: sometimes, a result is retrieved,
    # but its uniprot_id does not match the query uniprot_id
    if retrieved_metadata is None or retrieved_metadata.iloc[0].uniprot_id != uniprot_id:
        print('Warning: no metadata found for uniprot_id %s' % uniprot_id)
        return

    uniprot_metadata = models.UniprotMetadata(**retrieved_metadata.iloc[0])
    utils.add_and_commit(session, uniprot_metadata, errors=errors)


def insert_uniprot_metadata_for_crispr_design(
    session, crispr_design_id, retrieved_metadata=None, errors='warn'
):
    '''
    Retrieve and insert the raw uniprot metadata for a crispr design

    Parameters
    ----------
    crispr_design_id : int, required
        the id of the crispr design for which to insert uniprot metadata
    retrieved_metadata : one-row pd.Dataframe, optional
        The raw uniprot metadata corresponding to the crispr design
        (intended for edge cases in which the correct metadata must be manually specified,
        rather than retrieved by uniprot_utils.get_uniprot_metadata)
    '''

    crispr_design = (
        session.query(models.CrisprDesign)
        .filter(models.CrisprDesign.id == crispr_design_id)
        .one()
    )

    if crispr_design.uniprot_id is not None:
        return

    # retrieve the metadata for the crispr design from the UniprotKB API
    if retrieved_metadata is None:

        # first try querying with the ENST ID, if one was provided
        if crispr_design.transcript_id is not None:
            retrieved_metadata = uniprot_utils.query_uniprotkb(
                query=crispr_design.transcript_id, limit=1
            )

        # if there is no ENST ID or no metadata was found, query with the target name
        if crispr_design.transcript_id is None or retrieved_metadata is None:
            print(
                "Warning: querying UniprotKB by target name and not by ENST ID for '%s'"
                % crispr_design.target_name
            )
            retrieved_metadata = uniprot_utils.query_uniprotkb(
                query=crispr_design.target_name, limit=1
            )

    if retrieved_metadata is None:
        print('Warning: no Uniprot metadata found for target %s' % crispr_design.target_name)
        return
    retrieved_metadata = retrieved_metadata.iloc[0]

    # check whether the retrieved metadata already exists
    extant_metadata = (
        session.query(models.UniprotMetadata)
        .filter(models.UniprotMetadata.uniprot_id == retrieved_metadata.uniprot_id)
        .one_or_none()
    )
    if extant_metadata is None:
        uniprot_metadata = models.UniprotMetadata(**retrieved_metadata)
        utils.add_and_commit(session, uniprot_metadata, errors=errors)

    # update the crispr design's uniprot_id
    crispr_design.uniprot_id = retrieved_metadata.uniprot_id
    utils.add_and_commit(session, crispr_design, errors=errors)


def insert_ensg_id(session, uniprot_id):
    '''
    Retrieve and insert the ENSG ID in the uniprot_metadata table for a given uniprot_id
    (using the Uniprot mapper API to look up the ENSG ID)
    '''

    uniprot_metadata = (
        session.query(models.UniprotMetadata)
        .filter(models.UniprotMetadata.uniprot_id == uniprot_id)
        .one_or_none()
    )

    if uniprot_metadata is None:
        print('Warning: no uniprot metadata found for uniprot_id %s' % uniprot_id)
        return

    # NOTE: I manually switch to map_uniprot_to_ensg_using_uniprot here after trying mygene,
    # because there are, rarely, ids that are not in mygene but are in Uniprot's mapper API
    try:
        ensg_id = uniprot_utils.map_uniprot_to_ensg_using_mygene(uniprot_id)
    except Exception:
        print('Uncaught error for uniprot_id %s' % uniprot_id)
        return

    if ensg_id is None:
        print('Warning: no ENSG ID found for uniprot_id %s' % uniprot_id)
        return

    uniprot_metadata.ensg_id = ensg_id
    utils.add_and_commit(session, uniprot_metadata, errors='warn')


class PolyclonalLineOperations:
    '''
    '''

    def __init__(self, line):
        self.line = line


    @classmethod
    def from_line_id(cls, session, line_id, eager=False):
        '''
        '''
        query = session.query(models.CellLine)
        if eager:
            query = query.options(
                db.orm.joinedload(models.CellLine.fovs, innerjoin=True)
                .joinedload(models.MicroscopyFOV.results, innerjoin=True)
            )
        return cls(query.get(line_id))


    @classmethod
    def from_plate_well(cls, session, design_id, well_id):
        '''
        Convenience method to retrieve the cell line
        corresponding to a plate design and a well id
        (assuming that there is only one such cell line)
        '''

        design = (
            session.query(models.CrisprDesign)
            .filter(models.CrisprDesign.plate_design_id == design_id)
            .filter(models.CrisprDesign.well_id == well_id)
            .one_or_none()
        )
        if not design or not design.cell_lines:
            raise ValueError('No cell line found for well %s of plate %s' %
                (well_id, design_id))

        if len(design.cell_lines) > 1:
            raise ValueError('More than one cell line exists for well %s of plate %s' %
                (well_id, design_id))

        return cls(design.cell_lines[0])


    @classmethod
    def from_target_name(cls, session, target_name):
        '''
        Convenience method to retrieve the cell line for the given target_name

        If there is more than one cell_line for the target_name,
        then the PolyClonalLineOperations class is instantiated using the first such cell_line
        '''

        designs = (
            session.query(models.CrisprDesign)
            .filter(db.func.lower(models.CrisprDesign.target_name) == db.func.lower(target_name))
            .all()
        )

        lines = []
        [lines.extend(design.cell_lines) for design in designs]

        if len(lines) > 1:
            print(
                'Warning: returning the first of %s cell lines found for target_name %s' %
                (len(lines), target_name)
            )
        if not lines:
            raise ValueError("No cells lines found for target name '%s'" % target_name)

        return cls(lines[0])


    def insert_facs_dataset(self, session, histograms, scalars, errors='warn'):
        '''
        Insert the processed FACS data for a single polyclonal cell line
        '''

        # drop any existing data
        if self.line.facs_dataset:
            utils.delete_and_commit(session, self.line.facs_dataset)

        facs_dataset = models.FACSDataset(
            cell_line=self.line,
            scalars=utils.to_jsonable(scalars),
            histograms=utils.to_jsonable(histograms))
        utils.add_and_commit(session, facs_dataset, errors=errors)


    def insert_sequencing_dataset(self, session, scalars, errors='warn'):
        '''
        Insert a limited set of the sequencing results - just the HDR/all and HDR/modified ratios
        '''

        # drop any existing data
        if self.line.sequencing_dataset:
            utils.delete_and_commit(session, self.line.sequencing_dataset)

        sequencing_dataset = models.SequencingDataset(
            cell_line=self.line,
            scalars=utils.to_jsonable(scalars))
        utils.add_and_commit(session, sequencing_dataset, errors=errors)


    def insert_microscopy_fovs(self, session, metadata, errors='warn'):
        '''
        Insert a set of microscopy FOVs for the cell line

        metadata : dataframe of raw FOV metadata with the following columns:
        pml_id, imaging_round_id, site_num, raw_filepath
        '''

        fovs = self.line.fovs
        for _, row in metadata.iterrows():
            fov = models.MicroscopyFOV(
                cell_line=self.line,
                pml_id=row.pml_id,
                site_num=row.site_num,
                raw_filename=row.raw_filepath,
                imaging_round_id=row.imaging_round_id,
            )
            fovs.append(fov)
        utils.add_and_commit(session, fovs, errors=errors)
