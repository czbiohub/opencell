import os
import re
import sys
import glob
import json
import pickle
import imageio
import skimage
import hashlib
import datetime
import tifffile

import numpy as np
import pandas as pd

from opencell import constants
from opencell.imaging import images, utils


class FOVProcessor:

    def __init__(
        self,
        fov_id,
        pml_id,
        parental_line,
        plate_id,
        well_id,
        site_num,
        target_name,
        src_type,
        raw_filepath,
        all_roi_rows
    ):

        self.fov_id = fov_id
        self.pml_id = pml_id
        self.parental_line = parental_line
        self.plate_id = plate_id
        self.well_id = well_id
        self.site_num = site_num

        # the root directory type
        # (either 'plate_microscopy' or 'raw_pipeline_microscopy')
        self.src_type = src_type

        # see set_src_roots
        self.src_roots = {}

        # the path to the raw TIFF, relative to src_root
        self.raw_filepath = raw_filepath

        # array of dicts for all ROIs cropped from the FOV
        self.all_roi_rows = all_roi_rows

        # clean up the target_name (remove slashes and dashes)
        self.target_name = self.clean_target_name(target_name)

        # create site_id from site_num
        self.site_id = 'S%02d' % int(self.site_num)


    def set_src_roots(self, plate_microscopy_dir=None, raw_pipeline_microscopy_dir=None):
        '''
        Set the absolute paths to the 'PlateMicroscopy'
        and 'raw-pipeline-microscopy' directories

        On ESS, these should be
        '/gpfsML/ML_group/PlateMicroscopy/'
        '/gpfsML/ML_group/raw-pipeline-microscopy/'
        '''
        self.src_roots = {
            'plate_microscopy': plate_microscopy_dir,
            'raw_pipeline_microscopy': raw_pipeline_microscopy_dir
        }


    @staticmethod
    def clean_target_name(target_name):
        '''
        Create a filename-safe target_name by removing slashes and dashes
        '''
        forbidden_chars = ['-', '_', '/']
        for char in forbidden_chars:
            target_name = target_name.replace(char, '')
        return target_name


    @classmethod
    def from_database(cls, fov):
        '''
        Initialize a processor given a microscopy_fov instance from opencelldb

        Note that this method assumes that fov.cell_line is an 'original' polyclonal line
        (and not, for example, a descendent generated by re-sorting an original polyclonal line
        or a clonal descendent of a polyclonal line)
        '''

        well_id = fov.cell_line.electroporation_line.well_id
        plate_design = fov.cell_line.electroporation_line.electroporation.plate_instance.plate_design
        crispr_design = [d for d in plate_design.crispr_designs if d.well_id == well_id].pop()

        # roi_props for all ROIs cropped from this FOV (will often be empty)
        all_roi_rows = [roi.as_dict() for roi in fov.rois]

        processor = cls(
            fov_id=fov.id,
            pml_id=fov.dataset.pml_id,
            parental_line=fov.cell_line.parent.name,
            plate_id=plate_design.design_id,
            well_id=well_id,
            site_num=fov.site_num,
            src_type=fov.dataset.root_directory,
            raw_filepath=fov.raw_filename,
            target_name=crispr_design.target_name,
            all_roi_rows=all_roi_rows)

        return processor


    def z_step_size(self):
        '''
        Unpleasant method to determine the z-step size from the PML ID

        This method encodes the facts that, prior to ML0123 (aka PML0123),
        the step size was always 0.5um, and that starting at ML0123,
        the step size has always been 0.2um.

        NOTE: this method is necessary because the z-step size is *not* encoded
        in the MicroManager metadata or anywhere else
        '''
        z_step_size = 0.2
        critical_pml_num = 123
        pml_num = int(self.pml_id[3:])
        if pml_num < critical_pml_num:
            z_step_size = 0.5
        return z_step_size


    def src_filepath(self):
        '''
        Construct the absolute filepath to a TIFF stack
        in either the 'PlateMicroscopy' or 'raw-pipeline-microscopy' directory
        '''

        src_root = self.src_roots.get(self.src_type) or ''
        src_filepath = os.path.join(src_root, self.raw_filepath)
        return src_filepath


    def dst_plate_dir(self):
        '''
        Construct a dst plate_dir from an src plate_dir

        Destination plate directory names are of the form 'czML0383-P0001'
        '''
        dst_plate_dir = f'{self.parental_line}-{self.plate_id}'
        return dst_plate_dir


    def dst_filepath(
        self,
        dst_root=None,
        kind=None,
        channel=None,
        roi_id=None,
        roi_props=None,
        ext=None,
        makedirs=True
    ):
        '''
        Construct the relative directory path and filename for a given 'kind' of output file

        The full path is of the form '{kind}/{dst_plate_dir}/{dst_filename}'
        dst_plate_dir is of the form 'czML0383-P0001'
        dst_filename is of the form 'czML0383-P0001-A01-PML0123-S01_CLTA_{kind}-{channel}'

        If `kind` is 'crop' and if roi_coords are provided,
        then the roi_coords are included in the filename:
        'czML00383-P0001-A01-PML0123-S01_CLTA_CROP-0424-0000-0600-0600-CH405'

        '''

        if dst_root is None:
            dst_root = ''

        kinds = ['proj', 'crop', 'clean']
        if kind not in kinds:
            raise ValueError('%s is not a valid destination kind' % kind)
        appendix = kind.upper()

        # retrieve the roi_props if an roi_id was provided
        if roi_id is not None:
            row = [row for row in self.all_roi_rows if row['id'] == roi_id]
            if not row:
                raise ValueError('ROI %s is not an ROI of FOV %s' % (roi_id, self.fov_id))
            roi_props = row.pop()['props']

        # append the ROI coords if roi_props exists
        # (we don't validate these, but we assume they correspond to
        # (top_left_row, top_left_col, num_rows, num_cols))
        if kind == 'crop' and roi_props is not None:
            for coord in roi_props['xy_coords']:
                appendix = '%s-%04d' % (appendix, coord)

        # append the channel last, so that when sorting files,
        # the two channels of each FOV OR ROI remain adjacent to one another
        if channel is not None:
            appendix = '%s-CH%s' % (appendix, channel)

        # destination plate_dir name
        dst_plate_dir = self.dst_plate_dir()

        # construct the destination dirpath
        dst_dirpath = os.path.join(dst_root, kind, dst_plate_dir)
        if makedirs:
            os.makedirs(dst_dirpath, exist_ok=True)

        # construct the destination filename
        dst_filename = f'{dst_plate_dir}-{self.well_id}-{self.pml_id}-{self.site_id}_{self.target_name}_{appendix}.{ext}'  # noqa: E501
        return os.path.join(dst_dirpath, dst_filename)


    def load_raw_tiff(self):
        '''
        Convenience method to open and parse a raw TIFF and attempt to split it by channel
        Returns None if the file does not exist or cannot be split by channel
        '''
        src_filepath = self.src_filepath()
        if os.path.isfile(src_filepath):
            tiff = images.RawPipelineTIFF(src_filepath, verbose=False)
            tiff.parse_micromanager_metadata()
            tiff.validate_micromanager_metadata()
            tiff.split_channels()
            if tiff.did_split_channels:
                return tiff
            else:
                print('Warning: could not split the TIFF')
                tiff.tiff.close()


    def process_raw_tiff(self, dst_root):
        '''
        Process a single raw TIFF
            1) parse the micromanager and other metadata
            2) split the tiff pages into the z-stacks for the 405 and 488 channels
            3) generate z-projections

        dst_root : the path to the destination 'opencell-microscopy' directory

        NOTE: the `tiff.global_metadata` object returned by this method
        is modified by all of the `RawPipelineTIFF` methods called below
        (including by `project_stack`, which appends the min/max intensities)
        '''

        src_filepath = self.src_filepath()
        metadata = {'src_filepath': src_filepath}
        if not os.path.isfile(src_filepath):
            metadata['error'] = 'File does not exist'

        tiff = images.RawPipelineTIFF(src_filepath, verbose=False)
        tiff.parse_micromanager_metadata()
        tiff.validate_micromanager_metadata()

        # attempt to split the channels and project
        tiff.split_channels()
        if tiff.did_split_channels:
            for channel in [tiff.laser_405, tiff.laser_488]:
                dst_filepath = self.dst_filepath(
                    dst_root=dst_root, kind='proj', channel=channel, ext='tif')
                tiff.project_stack(channel_name=channel, axis='z', dst_filepath=dst_filepath)

        # the tiff file must be manually closed
        tiff.tiff.close()

        metadata.update(tiff.global_metadata)

        # return the parsed raw TIFF metadata and the parsing events (if any)
        result = {'metadata': metadata, 'events': tiff.events}
        return result


    def calculate_fov_features(self, dst_root, fov_scorer):
        '''
        Calculate the features and score for the FOV
        using the PipelineFOVScorer module from the dragonfly-automation project

        dst_root : the root directory in which z-projections were saved in process_raw_tiff
        fov_scorer : an instance of PipelineFOVScorer in 'training' mode
        '''

        # construct the filepath to the z-projection of the Hoechst staining
        filepath = self.dst_filepath(dst_root, kind='proj', channel='405', ext='tif')
        result = fov_scorer.process_existing_fov(filepath)
        return result


    def generate_fov_thumbnails(self, dst_root, scale, quality):
        '''
        Generate thumbnail images of the z-projections as base64-encoded JPGs
        '''
        filepath_405 = self.dst_filepath(dst_root, kind='proj', channel='405', ext='tif')
        filepath_488 = self.dst_filepath(dst_root, kind='proj', channel='488', ext='tif')

        ims = {}
        ims['405'] = tifffile.imread(filepath_405)[..., None]
        ims['488'] = tifffile.imread(filepath_488)[..., None]
        ims['rgb'] = self.make_rgb(ims['405'], ims['488'])

        b64_strings = {}
        for key, im in ims.items():
            # use downscale_local_mean to reduce noise
            im = skimage.transform.downscale_local_mean(im, factors=(scale, scale, 1))
            # crop the last row and column to eliminate edge effects
            im = im[:-1, :-1, :]
            # cast to uint8 again (downscale_local_mean outputs float64)
            im = utils.autoscale(im)
            # base64 encode
            b64_strings[key] = utils.b64encode_image(im, format='jpg', quality=quality)

        result = {
            'size': im.shape[0],
            'quality': quality,
            'b64_strings': b64_strings,
        }
        return result


    def calculate_z_profiles(self):
        '''
        '''
        # attempt to load and split the TIFF
        result = {}
        tiff = self.load_raw_tiff()
        if tiff is None:
            result['error'] = 'Raw TIFF file for fov %s does not exist' % self.fov_id
            return result

        for channel in (tiff.laser_405, tiff.laser_488):
            try:
                result[channel] = tiff.calculate_z_profiles(tiff.stacks[channel])
            except Exception as error:
                result[channel] = {'error': str(error)}
        return result


    def generate_clean_tiff(self, dst_root):
        '''
        Generate 'clean' but otherwise raw TIFFs for machine-learning pipelines by
            1) aligning the two channels to approximately correct for chromatic aberration in z
            2) centering and cropping the stacks around the cell layer in z
            3) downsampling stacks with 0.2um z-steps to 0.5um z-steps
        '''

        # the z-position of the top and bottom of the cell layer,
        # relative to the cell layer center, in microns
        rel_bottom = -5
        rel_top = 6

        result = {}
        tiff = self.load_raw_tiff()
        if tiff is None:
            result['error'] = 'Raw TIFF file for fov %s does not exist' % self.fov_id
            return result

        step_size = self.z_step_size()
        try:
            stacks, result = tiff.align_cell_layer(rel_bottom, rel_top, step_size)
        except Exception as error:
            result['error'] = str(error)

        # check if an error occurred above or in crop_and_align_cell_layer
        if result.get('error'):
            return result

        # if the step_size is 0.2um, downsample to 0.5um
        if step_size == 0.2:
            zscale = 0.2/0.5
            for channel in stacks:
                stacks[channel] = skimage.transform.rescale(
                    stacks[channel],
                    scale=(zscale, 1, 1),
                    multichannel=False,
                    preserve_range=True,
                    anti_aliasing=False,
                    order=1)
                stacks[channel] = stacks[channel].astype('uint16')

        # save the stacks as a hyperstack in CZXY order
        stack = np.concatenate((stacks['405'][None, :], stacks['488'][None, :]), axis=0)
        dst_filepath = self.dst_filepath(dst_root, kind='clean', ext='tif')
        tifffile.imsave(dst_filepath, stack, dtype='uint16')
        result['final_stack_shape'] = stack.shape
        return result


    def crop_corner_rois(self, dst_root):
        '''
        Crop a 600x600 ROI at each corner of the cell-layer-cropped z-stacks,
        downsample the intensities from uint16 to uint8, and save each ROI as a tiled PNG

        Returns
        -------
        all_roi_props : a list of ROI properties (empty if an error ocurred)

        TODO: more consistent/transparent error-handling
        (are we raising exceptions or returning an empty list?)

        '''

        all_roi_props = []

        # attempt to load and split the TIFF
        tiff = self.load_raw_tiff()
        if tiff is None:
            raise ValueError('Raw TIFF file for fov %s does not exist' % self.fov_id)

        # the size of the full FOV and the size of the ROIs to crop from each corner
        fov_size = 1024
        roi_size = 600

        # the top and bottom of the cell layer, relative to its center, in microns
        # (these were empirically determined)
        cell_layer_rel_bottom = -5
        cell_layer_rel_top = 6

        # the step size of the final stack in microns
        # (this is chosen to correspond to the xy pixel size,
        # so that the voxels of the resampled stack will be isotropic)
        target_step_size = 0.2

        # the number of slices the resampled stack must have
        # (should be equal to (rel_top - rel_buttom) / target_step_size)
        required_num_slices = 55

        # crop around the cell layer in z
        aligned_stacks, alignment_result = tiff.align_cell_layer(
            cell_layer_rel_bottom, cell_layer_rel_top, self.z_step_size())

        # for now, just exit silently if an error ocurred in cell layer alignment/cropping
        if alignment_result.get('error'):
            return all_roi_props

        # for now, the top and bottom inds are the full extent of the cropped stack
        bottom_ind = 0
        top_ind = aligned_stacks['405'].shape[0]

        # the shape of each ROI
        roi_shape = (roi_size, roi_size, top_ind - bottom_ind)

        # the position of the top left corner of each of the four ROIs
        min_ind = 0
        max_ind = fov_size - roi_size
        roi_top_left_positions = [
            (min_ind, min_ind, bottom_ind),
            (min_ind, max_ind, bottom_ind),
            (max_ind, min_ind, bottom_ind),
            (max_ind, max_ind, bottom_ind)
        ]

        for roi_position in roi_top_left_positions:
            roi_props = {
                'shape': roi_shape,
                'position': roi_position,
                'xy_coords': (*roi_position[:2], *roi_shape[:2]),
                'cell_layer_center_ind': alignment_result['cell_layer_center'],
                'target_step_size': target_step_size,
                'original_step_size': self.z_step_size(),
                'required_num_slices': required_num_slices,
            }

            roi_props = self.crop_and_save_roi(roi_props, aligned_stacks, dst_root)
            all_roi_props.append(roi_props)
        return all_roi_props


    def crop_best_roi(self, dst_root):
        '''
        Find and crop the ROI with the highest ROI score
        '''
        pass


    def crop_and_save_roi(self, roi_props, stacks, dst_root):
        '''
        Crop an ROI from the raw TIFF, resample it in z if necessary,
        downsample it from uint16 to uint8, and save it as a 1D tiled PNG
        '''

        num_rows, num_cols, num_z = roi_props['shape']
        row_ind, col_ind, z_ind = roi_props['position']

        for channel in stacks:
            dst_filepath = self.dst_filepath(
                dst_root,
                kind='crop',
                channel=channel,
                roi_props=roi_props,
                ext='jpg'
            )

            # crop the raw stack
            cropped_stack = stacks[channel][
                z_ind:(z_ind + num_z),
                row_ind:(row_ind + num_rows),
                col_ind:(col_ind + num_cols)
            ]
            cropped_stack = cropped_stack.copy()

            # move the z dimension from the first to the last axis
            cropped_stack = np.moveaxis(cropped_stack, 0, -1)

            # resample the stack in z so that it has the required z-step size
            # and number of z-slices
            cropped_stack, did_resample_stack = self.maybe_resample_stack(
                cropped_stack,
                original_step_size=roi_props['original_step_size'],
                target_step_size=roi_props['target_step_size'],
                required_num_slices=roi_props['required_num_slices'])

            # the did_resample_stack flag will always be the same for both channels
            roi_props['stacks_resampled'] = did_resample_stack

            # downsample the pixel intensities from uint16 to uint8
            cropped_stack, min_intensity, max_intensity = self.stack_to_uint8(
                cropped_stack, percentile=0.01)

            # log the black and white points used to downsample the intensities
            roi_props['min_intensity_%s' % channel] = min_intensity
            roi_props['max_intensity_%s' % channel] = max_intensity

            # save the stack itself
            # TODO: what to do when the file already exists?
            if not os.path.isfile(dst_filepath):
                cropped_stack = np.moveaxis(cropped_stack, -1, 0)
                tile = np.concatenate([zslice for zslice in cropped_stack], axis=0)
                imageio.imsave(dst_filepath, tile, format='jpg', quality=90)

        return roi_props


    def generate_ijclean(self, dst_root):
        '''
        Append the IJMetadata tags to the raw tiff so that it can be opened in ImageJ
        with the correct psuedocolors and black/white points
        '''
        # attempt to load and split the TIFF
        tiff = self.load_raw_tiff()
        if not tiff:
            return


    @staticmethod
    def maybe_resample_stack(stack, original_step_size, target_step_size, required_num_slices):
        '''
        Resample and possibly crop or pad a z-stack so that it has the specified number of z-slices

        stack : 3D numpy array with dimensions (x, y, z)
        original_step_size : the z-step size of the original stack (in microns)
        target_step_size : the z-step size after resampling (in microns)
        required_num_slices : the number of z-slices the resampled stack must have
            (usually chosen so that the voxels of the resampled stack will be isotropic)
        '''

        did_resample_stack = False

        # resample z to generate isotropic voxels
        if original_step_size != target_step_size:
            did_resample_stack = True
            z_scale = original_step_size/target_step_size
            stack = skimage.transform.rescale(
                stack,
                (1, 1, z_scale),
                multichannel=False,
                preserve_range=True,
                anti_aliasing=False,
                order=1)

        # pad or crop the stack in z so that there are the required number of slices
        num_rows, num_cols, num_slices = stack.shape
        if num_slices < required_num_slices:
            pad = np.zeros((num_rows, num_cols, required_num_slices - num_slices), dtype=stack.dtype)
            stack = np.concatenate((stack, pad), axis=2)

        elif num_slices > required_num_slices:
            num_extra = num_slices - required_num_slices
            crop_ind = int(np.floor(num_extra/2))
            if np.mod(num_extra, 2) == 0:
                stack = stack[:, :, crop_ind:-crop_ind]
            else:
                stack = stack[:, :, crop_ind:-(crop_ind + 1)]

        return stack, did_resample_stack


    @staticmethod
    def stack_to_uint8(stack, percentile):
        '''
        Downsample the raw uint16 pixel intensities to uint8
        and return the black and white points used to do so
        '''

        stack = stack.astype(float)
        minn, maxx = np.percentile(stack, (percentile, 100 - percentile))
        if minn == maxx:
            maxx = minn + 1

        stack -= minn
        stack[stack < minn] = 0
        stack /= (maxx - minn)
        stack[stack > 1] = 1

        stack = (255*stack).astype('uint8')
        return stack, int(minn), int(maxx)


    @staticmethod
    def stack_to_tile2d(stack, num_cols):
        '''
        Transform a z-stack into a 2D array of z-slices
        (currently unused)

        stack : 3D numpy array with dimensions (x, y, z)
        num_cols : the number of columns in the tile
        '''

        num_slices = stack.shape[-1]
        num_extra_slices = int(num_cols * np.ceil(num_slices/num_cols) - num_slices)
        extra_slices = np.zeros((*stack.shape[:2], num_extra_slices), dtype=stack.dtype)
        stack = np.concatenate((stack, extra_slices), axis=2)

        num_slices = stack.shape[-1]
        num_rows = int(num_slices/num_cols)

        rows = []
        for row_ind in range(num_rows):
            row = np.concatenate(
                [stack[:, :, col_ind + row_ind*num_cols] for col_ind in range(num_cols)], axis=1)
            rows.append(row)
        tile = np.concatenate(rows, axis=0)

        return tile


    @staticmethod
    def make_rgb(im_405, im_488):
        '''
        Construct an RGB image from z-projections (or single z-slices) of each channel
        im_405 : 2D numpy array (assumed to be the Hoechst staining)
        im_488 : 2D numpy array (assumed to be the GFP signal)
        '''

        if im_405.ndim == 2:
            im_405 = im_405[..., None]
        if im_488.ndim == 2:
            im_488 = im_488[..., None]

        # background subtract the hoechst
        im_405 = im_405.astype(float)
        im_405 -= im_405.mean()
        im_405[im_405 < 0] = 0

        # downscale to uint8 using 1% percentiles
        # (and bump the gamma for hoechst to make it stand out again the GFP a bit better)
        hoechst = utils.autoscale(im_405, percentile=1, gamma=.7)
        gfp = utils.autoscale(im_488, percentile=1)

        # set the blue channel to the maximum of the GFP and hoechst
        # (this is easier than summing the channels and dealing with uint8 overflow, etc)
        blue = np.concatenate((gfp, hoechst), axis=2).max(axis=2)[..., None]

        red, green = gfp, gfp
        rgb = np.concatenate((red, green, blue), axis=2)
        return rgb
